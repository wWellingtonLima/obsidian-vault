/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnchorDisplayText
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  includeNoteName: "headersOnly",
  whichHeadings: "allHeaders",
  includeNotice: false,
  sep: " ",
  suggest: true
};
var AnchorDisplayText = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.suggestionsRegistered = false;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new AnchorDisplayTextSettingTab(this.app, this));
    if (this.settings.suggest) {
      this.registerEditorSuggest(new AnchorDisplaySuggest(this));
      this.suggestionsRegistered = true;
    }
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        var _a;
        const cursor = editor.getCursor();
        const currentLine = editor.getLine(cursor.line);
        const lastChars = currentLine.slice(cursor.ch - 2, cursor.ch);
        if (lastChars !== "]]") {
          return;
        }
        const headerLinkPattern = /\[\[([^\]]+#[^|\n\r\]]+)\]\]/;
        const match = currentLine.slice(0, cursor.ch + 2).match(headerLinkPattern);
        if (match) {
          const headings = match[1].split("#");
          let displayText = "";
          if (this.settings.whichHeadings === "lastHeader") {
            displayText = headings[headings.length - 1];
          } else {
            displayText = headings[1];
            if (this.settings.whichHeadings === "allHeaders") {
              for (let i = 2; i < headings.length; i++) {
                displayText += this.settings.sep + headings[i];
              }
            }
          }
          const startIndex = ((_a = match.index) != null ? _a : 0) + match[0].length - 2;
          if (this.settings.includeNoteName === "noteNameFirst") {
            displayText = `${headings[0]}${this.settings.sep}${displayText}`;
          } else if (this.settings.includeNoteName === "noteNameLast") {
            displayText = `${displayText}${this.settings.sep}${headings[0]}`;
          }
          if (displayText.startsWith("^")) {
            displayText = displayText.slice(1);
          }
          editor.replaceRange(`|${displayText}`, { line: cursor.line, ch: startIndex }, void 0, "headerDisplayText");
          if (this.settings.includeNotice) {
            new import_obsidian.Notice(`Updated anchor link display text.`);
          }
        }
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AnchorDisplaySuggest = class extends import_obsidian.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.suggestionSelected = null;
    this.plugin = plugin;
  }
  onTrigger(cursor, editor) {
    if (!this.plugin.settings.suggest)
      return null;
    if (this.suggestionSelected) {
      if (this.suggestionSelected.ch === cursor.ch && this.suggestionSelected.line === cursor.line)
        return null;
      this.suggestionSelected = null;
      return null;
    }
    const currentLine = editor.getLine(cursor.line);
    const lastChars = currentLine.slice(cursor.ch - 2, cursor.ch);
    if (lastChars !== "]]")
      return null;
    const headerLinkPattern = /(\[\[([^\]]+#[^\n\r\]]+)\]\])$/;
    const match = currentLine.slice(0, cursor.ch).match(headerLinkPattern);
    if (!match)
      return null;
    return {
      start: {
        line: cursor.line,
        ch: match.index + match[1].length - 2
        // 2 less to keep closing brackets
      },
      end: {
        line: cursor.line,
        ch: match.index + match[1].length - 2
      },
      query: match[2]
    };
  }
  getSuggestions(context) {
    const headings = context.query.split("|")[0].split("#");
    let displayText = headings[1];
    if (displayText.startsWith("^")) {
      displayText = displayText.slice(1);
    }
    for (let i = 2; i < headings.length; i++) {
      displayText += this.plugin.settings.sep + headings[i];
    }
    const suggestion1 = {
      displayText,
      source: "Don't include note name"
    };
    const suggestion2 = {
      displayText: `${headings[0]}${this.plugin.settings.sep}${displayText}`,
      source: "Note name and than heading(s)"
    };
    const suggestion3 = {
      displayText: `${displayText}${this.plugin.settings.sep}${headings[0]}`,
      source: "Heading(s) and than note name"
    };
    return [suggestion1, suggestion2, suggestion3];
  }
  renderSuggestion(value, el) {
    const suggestionEl = el.parentElement;
    const suggestionContainerEl = suggestionEl.parentElement;
    if (suggestionContainerEl.childElementCount < 2) {
      const promptInstructionsEl = suggestionContainerEl.createDiv({ cls: "prompt-instructions" });
      const instructionEl = promptInstructionsEl.createDiv({ cls: "prompt-instruction" });
      instructionEl.createEl("span", { cls: "prompt-instruction-command", text: "\u21B5" });
      instructionEl.createEl("span", { text: "to accept" });
    }
    el.setAttribute("class", "suggestion-item mod-complex");
    const suggestionContentEl = el.createDiv({ cls: "suggestion-content" });
    suggestionContentEl.createDiv({ cls: "suggestion-title", text: value.displayText });
    suggestionContentEl.createDiv({ cls: "suggestion-note", text: value.source });
  }
  selectSuggestion(value, evt) {
    const editor = this.context.editor;
    const displayTextPattern = /\|([^\]]+)/;
    const match = this.context.query.match(displayTextPattern);
    if (match) {
      this.context.start.ch = this.context.start.ch - match[0].length;
    }
    editor.replaceRange(`|${value.displayText}`, this.context.start, this.context.end, "headerDisplayText");
    this.suggestionSelected = this.context.end;
  }
};
var AnchorDisplayTextSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.sepWarning = null;
    this.plugin = plugin;
  }
  validateSep(value) {
    let validValue = value;
    for (const c of value) {
      if ("[]#^|".includes(c)) {
        validValue = validValue.replace(c, "");
      }
    }
    if (validValue != value) {
      if (!this.sepWarning) {
        this.sepWarning = new import_obsidian.Notice(`Separators cannot contain any of the following characters: []#^|`, 0);
      }
    } else {
      if (this.sepWarning) {
        this.sepWarning.hide();
        this.sepWarning = null;
      }
    }
    return validValue;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Include note name").setDesc("Include the title of the note in the display text.").addDropdown((dropdown) => {
      dropdown.addOption("headersOnly", "Don't include note name");
      dropdown.addOption("noteNameFirst", "Note name and then heading(s)");
      dropdown.addOption("noteNameLast", "Heading(s) and then note name");
      dropdown.setValue(this.plugin.settings.includeNoteName);
      dropdown.onChange((value) => {
        this.plugin.settings.includeNoteName = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Include subheadings").setDesc("Change which headings and subheadings are in the display text.").addDropdown((dropdown) => {
      dropdown.addOption("allHeaders", "All linked headings");
      dropdown.addOption("lastHeader", "Last heading only");
      dropdown.addOption("firstHeader", "First heading only");
      dropdown.setValue(this.plugin.settings.whichHeadings);
      dropdown.onChange((value) => {
        this.plugin.settings.whichHeadings = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Separator").setDesc("Choose what to insert between headings instead of #.").addText((text) => {
      text.setValue(this.plugin.settings.sep);
      text.onChange((value) => {
        this.plugin.settings.sep = this.validateSep(value);
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Enable notifications").setDesc("Have a notice pop up whenever an anchor link is automatically changed.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.includeNotice);
      toggle.onChange((value) => {
        this.plugin.settings.includeNotice = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Suggest alternatives").setDesc("Have a suggestion window to present alternative display text options when the cursor is directly after an anchor link.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.suggest);
      toggle.onChange((value) => {
        this.plugin.settings.suggest = value;
        this.plugin.saveSettings();
        if (!this.plugin.suggestionsRegistered) {
          this.plugin.registerEditorSuggest(new AnchorDisplaySuggest(this.plugin));
          this.plugin.suggestionsRegistered = true;
        }
      });
    });
  }
};


/* nosourcemap */